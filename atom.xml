<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pader&#39;s Blog</title>
  <subtitle>Pader&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://paderlol.cn/"/>
  <updated>2018-10-20T13:25:54.045Z</updated>
  <id>http://paderlol.cn/</id>
  
  <author>
    <name>Pader</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Boot 2.0 外部化配置介绍</title>
    <link href="http://paderlol.cn/spring-boot01.html"/>
    <id>http://paderlol.cn/spring-boot01.html</id>
    <published>2018-10-20T07:38:22.000Z</published>
    <updated>2018-10-20T13:25:54.045Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/spring-boot01/spring-boot.png" alt="spring-boot"></p>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><blockquote>
<p>在应用中管理配置并不是一个容易的任务，尤其是在应用需要部署到多个环境中时。通常会需要为每个环境提供一个对应的属性文件，用来配置各自的数据库连接信息、服务器信息和第三方服务账号等。通常的应用部署会包含开发、测试和生产等若干个环境。不同的环境之间的配置存在覆盖关系。测试环境中的配置会覆盖开发环境，而生产环境中的配置会覆盖测试环境。Spring 框架本身提供了多种的方式来管理配置属性文件。Spring 3.1 之前可以使用 PropertyPlaceholderConfigurer。Spring 3.1 引入了新的环境（Environment）和概要信息（Profile）API，是一种更加灵活的处理不同环境和配置文件的方式。不过 Spring 这些配置管理方式的问题在于选择太多，让开发人员无所适从。Spring Boot 提供了一种统一的方式来管理应用的配置，允许开发人员使用属性文件、YAML 文件、环境变量和命令行参数来定义优先级不同的配置值。</p>
</blockquote>
<a id="more"></a>
<p>Spring Boot 可以使用外部化配置来方便在不同环境的运行同样的程序</p>
<ul>
<li>properties 文件</li>
<li>YAML 文件</li>
<li>环境变量</li>
<li>命令行参数</li>
</ul>
<h4 id="内置顺序"><a href="#内置顺序" class="headerlink" title="内置顺序"></a>内置顺序</h4><p>Spring Boot 实现了很多<code>PropertySource</code>,按以下顺序,进行合理的相同属性的覆盖:</p>
<ol>
<li><p>home目录下的devtools全局设置属性（~/.spring-boot-devtools.properties，如果devtools激活）</p>
</li>
<li><p>测试用例上的@TestPropertySource注解.</p>
</li>
<li><p>测试用例上的@SpringBootTest#properties注解。</p>
</li>
<li><p>命令行参数</p>
</li>
<li><p>来自SPRING_APPLICATION_JSON的属性（环境变量或系统属性中内嵌的内联JSON）</p>
</li>
<li><p>ServletConfig初始化参数.</p>
</li>
<li><p>ServletContext初始化参数.</p>
</li>
<li><p>来自于java:comp/env的JNDI属性.</p>
</li>
<li><p>Java系统属性 (<code>System.getProperties()</code>).</p>
</li>
<li><p>操作系统环境变量.</p>
</li>
<li><p>RandomValuePropertySource，只包含random.*中的属性.</p>
</li>
<li><p>jar包或者war包之外Profile-specific应用属性（<code>application-{profile}.properties</code>和YAML变量）.</p>
</li>
<li><p>Jar包内的的Profile-specific应用属性 (<code>application-{profile}.properties</code> and YAML 变量).</p>
</li>
<li><p>Application properties outside of your packaged jar (<code>application.properties</code> and YAML 变量).</p>
</li>
<li><p>Application properties packaged inside your jar (<code>application.properties</code> and YAML 变量).</p>
</li>
<li><p>配置在<code>@Configuration</code> 类上<a href="https://docs.spring.io/spring/docs/5.0.8.RELEASE/javadoc-api/org/springframework/context/annotation/PropertySource.html" target="_blank" rel="noopener"><code>@PropertySource</code></a> 注解.</p>
</li>
<li><p>SpringApplication.setDefaultProperties 指定的默认属性</p>
</li>
</ol>
<p><strong>Note</strong>:</p>
<ul>
<li>以上是Spring-Boot内部的默认顺序,并不是<strong>绝对顺序</strong>,实际扩展的时候需要注意顺序问题,后续我会在实践篇去说明这个。</li>
</ul>
<h4 id="Spring-Boot-1-5-vs-2-0-变化"><a href="#Spring-Boot-1-5-vs-2-0-变化" class="headerlink" title="Spring Boot 1.5 vs 2.0 变化"></a>Spring Boot 1.5 vs 2.0 变化</h4><ol>
<li><p>Relaxed Binding(宽松绑定规则)</p>
<ul>
<li>属性源绑定规则</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>Property</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>acme.my-project.person.first-name</code></td>
<td>建议在 <code>.properties</code> and <code>.yml</code> 文件中使用.</td>
</tr>
<tr>
<td><code>acme.myProject.person.firstName</code></td>
<td>标准的驼峰命名</td>
</tr>
<tr>
<td><code>acme.my_project.person.first_name</code></td>
<td>下划线命名, <code>.properties</code> and <code>.yml</code> 文件中使用.</td>
</tr>
<tr>
<td><code>ACME_MYPROJECT_PERSON_FIRSTNAME</code></td>
<td>大写下划线命名, 在环境变量中使用.</td>
</tr>
</tbody>
</table>
<p>   <strong>注意</strong>：</p>
<blockquote>
<ul>
<li><p>在尽可能的情况下,请使用小写的短横线命名的方法会,比如： <code>my.property-name=acme</code></p>
</li>
<li><p>在注解<strong>@ConfigurationProperties</strong>中定义或者在<strong>@ConditionalOnProperty</strong>的时候属性名<strong>前缀</strong>的时候必须使用<strong>短横分隔命名,并且必须小写</strong>,只有注解中命名的时候必须遵守这个命名规则。我发现有些文章描述这个变化是不准确的,并不是所有情况下都是需要这样，比如我可以在配置文件中使用上述表格中的命名方式。</p>
</li>
</ul>
</blockquote>
<ul>
<li><p><code>RelaxedPropertyResolver</code> 类解析工具被删除掉,由<code>Environment</code>类代替</p>
</li>
<li><p><code>RelaxedDataBinder</code> 类绑定工具类被删除掉,在2.0.0之后使用<code>Binder</code>类,如下使用方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyProperties target = Binder.get(environment)</span><br><span class="line">		.bind(<span class="string">"app.acme"</span>, MyProperties.class)</span><br><span class="line">		.orElse(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">FlagType flagType = Binder.get(environment)</span><br><span class="line">		.bind(<span class="string">"acme.app.my-flag"</span>, FlagType.class)</span><br><span class="line">		.orElse(FlagType.DEFAULT);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="2">
<li><p>在2.0之前的版本可以使用get/set方式注入静态变量,2.0以后不再支持</p>
</li>
<li><p><strong>@ConfigurationProperties Validation</strong></p>
<p>如果在2.0之后的版本需要在<code>@ConfigurationProperties</code>配置的类中使用验证必须使用<code>@Validated</code>注解</p>
</li>
<li><p><strong>Configuration Location</strong></p>
<p><code>spring.config.location</code> 属性在2.0之前的版本中会默认增加一个新的文件目录或者文件,在2.0的版本中,如果还要使用之前的功能,请使用<strong>spring.config.additional-location</strong></p>
</li>
</ol>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ol>
<li><a href="https://docs.spring.io/spring-boot/docs/2.0.3.RELEASE/reference/htmlsingle/#boot-features-external-config-validation" target="_blank" rel="noopener">Spring Boot Reference Guide-2.0.3</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/1.5.8.RELEASE/reference/htmlsingle/#boot-features-external-config-validation" target="_blank" rel="noopener">Spring Boot Reference Guide-1.5.8</a></li>
<li><a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Configuration-Changelog" target="_blank" rel="noopener">Spring Boot 2.0 Configuration Changelog</a></li>
<li><a href="https://github.com/spring-projects/spring-boot/wiki/Relaxed-Binding-2.0" target="_blank" rel="noopener">Relaxed Binding 2.0</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/spring-boot01/spring-boot.png&quot; alt=&quot;spring-boot&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;在应用中管理配置并不是一个容易的任务，尤其是在应用需要部署到多个环境中时。通常会需要为每个环境提供一个对应的属性文件，用来配置各自的数据库连接信息、服务器信息和第三方服务账号等。通常的应用部署会包含开发、测试和生产等若干个环境。不同的环境之间的配置存在覆盖关系。测试环境中的配置会覆盖开发环境，而生产环境中的配置会覆盖测试环境。Spring 框架本身提供了多种的方式来管理配置属性文件。Spring 3.1 之前可以使用 PropertyPlaceholderConfigurer。Spring 3.1 引入了新的环境（Environment）和概要信息（Profile）API，是一种更加灵活的处理不同环境和配置文件的方式。不过 Spring 这些配置管理方式的问题在于选择太多，让开发人员无所适从。Spring Boot 提供了一种统一的方式来管理应用的配置，允许开发人员使用属性文件、YAML 文件、环境变量和命令行参数来定义优先级不同的配置值。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://paderlol.cn/categories/SpringBoot/"/>
    
    
  </entry>
  
</feed>
